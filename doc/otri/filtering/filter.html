<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.4" />
<title>otri.filtering.filter API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9;--font-color:#111;--back-color:#eee;--blockquote:#ddd;--code-back:#e5e5e5}.flex{display:flex !important}body{line-height:1.5em;color:var(--font-color);background-color:var(--back-color)}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:500}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:var(--code-back);font-size:.8em;line-height:1.4em}code{padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid var(--blockquote);padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js" integrity="sha256-eOgo0OtLL4cdq7RdwRUiGKLX9XsIJ7nGhWEKbohmVAQ=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>otri.filtering.filter</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from typing import Sequence, Mapping, Any
from .stream import Stream


class Filter:
    &#39;&#39;&#39;
    Class that defines an atom manipulation filter.
    To change the order of input streams inspection override the _input_check_order method.
    &#39;&#39;&#39;

    def __init__(self, inputs: Sequence[str], outputs: Sequence[str], input_count: int = 0, output_count: int = 0):
        &#39;&#39;&#39;
        Parameters:
            inputs : Sequence[str]
                Name for input streams.
            outputs : Sequence[str]
                Name for output streams.

            If there are multiple streams for input or output the filter must explicit the right order for the user to name them correctly.
            Both input and output streams will be gathered/saved inside the FilterNet&#39;s dictionary of streams.

            Reserved to sub-classes:
                input_count : int
                    The number of input streams that the filter uses.
                output_count : int
                    The number of output streams that the filter uses.

                Both these numbers will be used to ensure that the filter gets the right amount of parameters.
        Raises:
            ValueError
                if the given input or output sequence has a different cardinality than expected.
        &#39;&#39;&#39;
        if(len(inputs) != input_count):
            raise ValueError(&#34;this filter takes {} input streams, {} given&#34;.format(
                input_count, len(inputs)))
        if(len(outputs) != output_count):
            raise ValueError(&#34;this filter takes {} output streams, {} given&#34;.format(
                output_count, len(outputs)))
        self.__output_names = outputs
        self.__input_names = inputs
        self._has_outputted = False

    def setup(self, inputs: Sequence[Stream], outputs: Sequence[Stream], state: Mapping[str, Any]):
        &#39;&#39;&#39;
        Allows the filter to save references to streams and reset its variables before the execution.
        Parameters:
            inputs, outputs : Sequence[Stream]
                Ordered sequence containing the required input/output streams gained from the FilterNet.
            state : Mapping[str, Any]
                Dictionary containing states to output.
        &#39;&#39;&#39;
        # Save references to streams
        self.__input_streams = inputs
        self.__output_streams = outputs
        self.__state = state

        # Save references to iterators
        self.__input_iters = list()
        self.__output_iters = list()
        for stream in inputs:
            self.__input_iters.append(iter(stream))
        for stream in outputs:
            self.__output_iters.append(iter(stream))

    def execute(self):
        &#39;&#39;&#39;
        This method gets called by the FilterNet when the filter has to manipulate data.
        It should:
        - Pop a single piece of data from one of the input streams.
        - Elaborate it and optionally update its state.
        - If it has produced something, push it into the output streams.
        &#39;&#39;&#39;
        # Checks if the filter has finished
        if self.__are_outputs_closed():
            self._on_outputs_closed()
            return

        self._has_outputted = False
        # Extracts input data sequentially from each input filter
        for i in self._input_check_order():
            if self.__input_iters[i].has_next():
                self._on_data(next(self.__input_iters[i]),i)
                return

        # Checks if any of the input streams is still open
        for input_stream in self.__input_streams:
            if not input_stream.is_closed():
                self._on_inputs_empty()
                return
        
        # No more data and all of the inputs closed
        self._on_inputs_closed()


    def get_input_names(self) -&gt; Sequence[str]:
        &#39;&#39;&#39;
        Retrieve the input streams names.
        &#39;&#39;&#39;
        return self.__input_names

    def get_output_names(self) -&gt; Sequence[str]:
        &#39;&#39;&#39;
        Retrieve the output streams names.
        &#39;&#39;&#39;
        return self.__output_names

    def _get_input(self, index: int = 0) -&gt; Stream:
        &#39;&#39;&#39;
        Retrieves one specific input stream.
        &#39;&#39;&#39;
        return self.__input_streams[index]

    def _get_inputs(self) -&gt; Sequence[Stream]:
        &#39;&#39;&#39;
        Retrieves all of the input streams.
        &#39;&#39;&#39;
        return self.__input_streams

    def _get_output(self, index: int = 0) -&gt; Stream:
        &#39;&#39;&#39;
        Retrieves one specific output stream.
        &#39;&#39;&#39;
        return self.__output_streams[index]

    def _get_outputs(self) -&gt; Sequence[Stream]:
        &#39;&#39;&#39;
        Retrieves all of the output streams.
        &#39;&#39;&#39;
        return self.__output_streams

    def _get_in_iter(self, index: int = 0) -&gt; Stream:
        &#39;&#39;&#39;
        Retrieves one specific input stream&#39;s iterator.
        &#39;&#39;&#39;
        return self.__input_iters[index]

    def _get_out_iter(self, index: int = 0) -&gt; Stream:
        &#39;&#39;&#39;
        Retrieves one specific output stream&#39;s iterator.
        &#39;&#39;&#39;
        return self.__output_iters[index]

    def _pop_data(self, index: int = 0) -&gt; Any:
        &#39;&#39;&#39;
        Pops one piece of data from an input.
        &#39;&#39;&#39;
        return next(self.__input_iters[index])

    def _push_data(self, data: Any, index: int = 0):
        &#39;&#39;&#39;
        Pushes one piece of data in an output.
        &#39;&#39;&#39;
        self._has_outputted = True
        self.__output_streams[index].append(data)

    # OVERRIDABLE METHODS

    def _on_outputs_closed(self):
        &#39;&#39;&#39;
        Called when all of the outputs have already been closed.
        &#39;&#39;&#39;
        pass

    def _on_data(self, data : Any, index : int):
        &#39;&#39;&#39;
        Called when one of the inputs has some data and it&#39;s been popped.
        Input could be still open or closed.

        Parameters:
            data : Any
                Popped data from an input.
            index : int
                The index of the input the data has been popped from.
        &#39;&#39;&#39;
        pass

    def _on_inputs_empty(self):
        &#39;&#39;&#39;
        All of the inputs have no data, but not all of them are closed.
        &#39;&#39;&#39;
        pass

    def _on_inputs_closed(self):
        &#39;&#39;&#39;
        All of the inputs are closed and no more data is available.
        The filter should empty itself and close all of the output streams.
        &#39;&#39;&#39;
        for out_stream in self.__output_streams:
            out_stream.close()
    
    def _input_check_order(self)-&gt;Sequence:
        &#39;&#39;&#39;
        Defines the order for the inputs to be checked.
        By default its just an ordered sequence from 0 to len(inputs).
        &#39;&#39;&#39;
        return range(0, len(self.__input_iters))

    # PRIVATE METHODS

    def __are_outputs_closed(self):
        for stream in self.__output_streams:
            if not stream.is_closed():
                return False
        return True</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="otri.filtering.filter.Filter"><code class="flex name class">
<span>class <span class="ident">Filter</span></span>
<span>(</span><span>inputs: Sequence[str], outputs: Sequence[str], input_count: int = 0, output_count: int = 0)</span>
</code></dt>
<dd>
<div class="desc"><p>Class that defines an atom manipulation filter.
To change the order of input streams inspection override the _input_check_order method.</p>
<h2 id="parameters">Parameters</h2>
<p>inputs : Sequence[str]
Name for input streams.
outputs : Sequence[str]
Name for output streams.</p>
<p>If there are multiple streams for input or output the filter must explicit the right order for the user to name them correctly.
Both input and output streams will be gathered/saved inside the FilterNet's dictionary of streams.</p>
<p>Reserved to sub-classes:
input_count : int
The number of input streams that the filter uses.
output_count : int
The number of output streams that the filter uses.</p>
<pre><code>Both these numbers will be used to ensure that the filter gets the right amount of parameters.
</code></pre>
<h2 id="raises">Raises</h2>
<p>ValueError
if the given input or output sequence has a different cardinality than expected.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Filter:
    &#39;&#39;&#39;
    Class that defines an atom manipulation filter.
    To change the order of input streams inspection override the _input_check_order method.
    &#39;&#39;&#39;

    def __init__(self, inputs: Sequence[str], outputs: Sequence[str], input_count: int = 0, output_count: int = 0):
        &#39;&#39;&#39;
        Parameters:
            inputs : Sequence[str]
                Name for input streams.
            outputs : Sequence[str]
                Name for output streams.

            If there are multiple streams for input or output the filter must explicit the right order for the user to name them correctly.
            Both input and output streams will be gathered/saved inside the FilterNet&#39;s dictionary of streams.

            Reserved to sub-classes:
                input_count : int
                    The number of input streams that the filter uses.
                output_count : int
                    The number of output streams that the filter uses.

                Both these numbers will be used to ensure that the filter gets the right amount of parameters.
        Raises:
            ValueError
                if the given input or output sequence has a different cardinality than expected.
        &#39;&#39;&#39;
        if(len(inputs) != input_count):
            raise ValueError(&#34;this filter takes {} input streams, {} given&#34;.format(
                input_count, len(inputs)))
        if(len(outputs) != output_count):
            raise ValueError(&#34;this filter takes {} output streams, {} given&#34;.format(
                output_count, len(outputs)))
        self.__output_names = outputs
        self.__input_names = inputs
        self._has_outputted = False

    def setup(self, inputs: Sequence[Stream], outputs: Sequence[Stream], state: Mapping[str, Any]):
        &#39;&#39;&#39;
        Allows the filter to save references to streams and reset its variables before the execution.
        Parameters:
            inputs, outputs : Sequence[Stream]
                Ordered sequence containing the required input/output streams gained from the FilterNet.
            state : Mapping[str, Any]
                Dictionary containing states to output.
        &#39;&#39;&#39;
        # Save references to streams
        self.__input_streams = inputs
        self.__output_streams = outputs
        self.__state = state

        # Save references to iterators
        self.__input_iters = list()
        self.__output_iters = list()
        for stream in inputs:
            self.__input_iters.append(iter(stream))
        for stream in outputs:
            self.__output_iters.append(iter(stream))

    def execute(self):
        &#39;&#39;&#39;
        This method gets called by the FilterNet when the filter has to manipulate data.
        It should:
        - Pop a single piece of data from one of the input streams.
        - Elaborate it and optionally update its state.
        - If it has produced something, push it into the output streams.
        &#39;&#39;&#39;
        # Checks if the filter has finished
        if self.__are_outputs_closed():
            self._on_outputs_closed()
            return

        self._has_outputted = False
        # Extracts input data sequentially from each input filter
        for i in self._input_check_order():
            if self.__input_iters[i].has_next():
                self._on_data(next(self.__input_iters[i]),i)
                return

        # Checks if any of the input streams is still open
        for input_stream in self.__input_streams:
            if not input_stream.is_closed():
                self._on_inputs_empty()
                return
        
        # No more data and all of the inputs closed
        self._on_inputs_closed()


    def get_input_names(self) -&gt; Sequence[str]:
        &#39;&#39;&#39;
        Retrieve the input streams names.
        &#39;&#39;&#39;
        return self.__input_names

    def get_output_names(self) -&gt; Sequence[str]:
        &#39;&#39;&#39;
        Retrieve the output streams names.
        &#39;&#39;&#39;
        return self.__output_names

    def _get_input(self, index: int = 0) -&gt; Stream:
        &#39;&#39;&#39;
        Retrieves one specific input stream.
        &#39;&#39;&#39;
        return self.__input_streams[index]

    def _get_inputs(self) -&gt; Sequence[Stream]:
        &#39;&#39;&#39;
        Retrieves all of the input streams.
        &#39;&#39;&#39;
        return self.__input_streams

    def _get_output(self, index: int = 0) -&gt; Stream:
        &#39;&#39;&#39;
        Retrieves one specific output stream.
        &#39;&#39;&#39;
        return self.__output_streams[index]

    def _get_outputs(self) -&gt; Sequence[Stream]:
        &#39;&#39;&#39;
        Retrieves all of the output streams.
        &#39;&#39;&#39;
        return self.__output_streams

    def _get_in_iter(self, index: int = 0) -&gt; Stream:
        &#39;&#39;&#39;
        Retrieves one specific input stream&#39;s iterator.
        &#39;&#39;&#39;
        return self.__input_iters[index]

    def _get_out_iter(self, index: int = 0) -&gt; Stream:
        &#39;&#39;&#39;
        Retrieves one specific output stream&#39;s iterator.
        &#39;&#39;&#39;
        return self.__output_iters[index]

    def _pop_data(self, index: int = 0) -&gt; Any:
        &#39;&#39;&#39;
        Pops one piece of data from an input.
        &#39;&#39;&#39;
        return next(self.__input_iters[index])

    def _push_data(self, data: Any, index: int = 0):
        &#39;&#39;&#39;
        Pushes one piece of data in an output.
        &#39;&#39;&#39;
        self._has_outputted = True
        self.__output_streams[index].append(data)

    # OVERRIDABLE METHODS

    def _on_outputs_closed(self):
        &#39;&#39;&#39;
        Called when all of the outputs have already been closed.
        &#39;&#39;&#39;
        pass

    def _on_data(self, data : Any, index : int):
        &#39;&#39;&#39;
        Called when one of the inputs has some data and it&#39;s been popped.
        Input could be still open or closed.

        Parameters:
            data : Any
                Popped data from an input.
            index : int
                The index of the input the data has been popped from.
        &#39;&#39;&#39;
        pass

    def _on_inputs_empty(self):
        &#39;&#39;&#39;
        All of the inputs have no data, but not all of them are closed.
        &#39;&#39;&#39;
        pass

    def _on_inputs_closed(self):
        &#39;&#39;&#39;
        All of the inputs are closed and no more data is available.
        The filter should empty itself and close all of the output streams.
        &#39;&#39;&#39;
        for out_stream in self.__output_streams:
            out_stream.close()
    
    def _input_check_order(self)-&gt;Sequence:
        &#39;&#39;&#39;
        Defines the order for the inputs to be checked.
        By default its just an ordered sequence from 0 to len(inputs).
        &#39;&#39;&#39;
        return range(0, len(self.__input_iters))

    # PRIVATE METHODS

    def __are_outputs_closed(self):
        for stream in self.__output_streams:
            if not stream.is_closed():
                return False
        return True</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="otri.filtering.filters.generic_filter.GenericFilter" href="filters/generic_filter.html#otri.filtering.filters.generic_filter.GenericFilter">GenericFilter</a></li>
<li><a title="otri.filtering.filters.interpolation_filter.InterpolationFilter" href="filters/interpolation_filter.html#otri.filtering.filters.interpolation_filter.InterpolationFilter">InterpolationFilter</a></li>
<li><a title="otri.filtering.filters.math_filter.MathFilter" href="filters/math_filter.html#otri.filtering.filters.math_filter.MathFilter">MathFilter</a></li>
<li><a title="otri.filtering.filters.merge_filter.SequentialMergeFilter" href="filters/merge_filter.html#otri.filtering.filters.merge_filter.SequentialMergeFilter">SequentialMergeFilter</a></li>
<li><a title="otri.filtering.filters.nuplicator_filter.NUplicatorFilter" href="filters/nuplicator_filter.html#otri.filtering.filters.nuplicator_filter.NUplicatorFilter">NUplicatorFilter</a></li>
<li><a title="otri.filtering.filters.phase_filter.PhaseFilter" href="filters/phase_filter.html#otri.filtering.filters.phase_filter.PhaseFilter">PhaseFilter</a></li>
<li><a title="otri.filtering.filters.split_filter.SplitFilter" href="filters/split_filter.html#otri.filtering.filters.split_filter.SplitFilter">SplitFilter</a></li>
<li><a title="otri.filtering.filters.split_filter.SwitchFilter" href="filters/split_filter.html#otri.filtering.filters.split_filter.SwitchFilter">SwitchFilter</a></li>
<li><a title="otri.filtering.filters.statistics_filter.StatisticsFilter" href="filters/statistics_filter.html#otri.filtering.filters.statistics_filter.StatisticsFilter">StatisticsFilter</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="otri.filtering.filter.Filter.execute"><code class="name flex">
<span>def <span class="ident">execute</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This method gets called by the FilterNet when the filter has to manipulate data.
It should:
- Pop a single piece of data from one of the input streams.
- Elaborate it and optionally update its state.
- If it has produced something, push it into the output streams.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def execute(self):
    &#39;&#39;&#39;
    This method gets called by the FilterNet when the filter has to manipulate data.
    It should:
    - Pop a single piece of data from one of the input streams.
    - Elaborate it and optionally update its state.
    - If it has produced something, push it into the output streams.
    &#39;&#39;&#39;
    # Checks if the filter has finished
    if self.__are_outputs_closed():
        self._on_outputs_closed()
        return

    self._has_outputted = False
    # Extracts input data sequentially from each input filter
    for i in self._input_check_order():
        if self.__input_iters[i].has_next():
            self._on_data(next(self.__input_iters[i]),i)
            return

    # Checks if any of the input streams is still open
    for input_stream in self.__input_streams:
        if not input_stream.is_closed():
            self._on_inputs_empty()
            return
    
    # No more data and all of the inputs closed
    self._on_inputs_closed()</code></pre>
</details>
</dd>
<dt id="otri.filtering.filter.Filter.get_input_names"><code class="name flex">
<span>def <span class="ident">get_input_names</span></span>(<span>self) ‑> Sequence[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve the input streams names.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_input_names(self) -&gt; Sequence[str]:
    &#39;&#39;&#39;
    Retrieve the input streams names.
    &#39;&#39;&#39;
    return self.__input_names</code></pre>
</details>
</dd>
<dt id="otri.filtering.filter.Filter.get_output_names"><code class="name flex">
<span>def <span class="ident">get_output_names</span></span>(<span>self) ‑> Sequence[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve the output streams names.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_output_names(self) -&gt; Sequence[str]:
    &#39;&#39;&#39;
    Retrieve the output streams names.
    &#39;&#39;&#39;
    return self.__output_names</code></pre>
</details>
</dd>
<dt id="otri.filtering.filter.Filter.setup"><code class="name flex">
<span>def <span class="ident">setup</span></span>(<span>self, inputs: Sequence[<a title="otri.filtering.stream.Stream" href="stream.html#otri.filtering.stream.Stream">Stream</a>], outputs: Sequence[<a title="otri.filtering.stream.Stream" href="stream.html#otri.filtering.stream.Stream">Stream</a>], state: Mapping[str, Any])</span>
</code></dt>
<dd>
<div class="desc"><p>Allows the filter to save references to streams and reset its variables before the execution.</p>
<h2 id="parameters">Parameters</h2>
<p>inputs, outputs : Sequence[Stream]
Ordered sequence containing the required input/output streams gained from the FilterNet.
state : Mapping[str, Any]
Dictionary containing states to output.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setup(self, inputs: Sequence[Stream], outputs: Sequence[Stream], state: Mapping[str, Any]):
    &#39;&#39;&#39;
    Allows the filter to save references to streams and reset its variables before the execution.
    Parameters:
        inputs, outputs : Sequence[Stream]
            Ordered sequence containing the required input/output streams gained from the FilterNet.
        state : Mapping[str, Any]
            Dictionary containing states to output.
    &#39;&#39;&#39;
    # Save references to streams
    self.__input_streams = inputs
    self.__output_streams = outputs
    self.__state = state

    # Save references to iterators
    self.__input_iters = list()
    self.__output_iters = list()
    for stream in inputs:
        self.__input_iters.append(iter(stream))
    for stream in outputs:
        self.__output_iters.append(iter(stream))</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="otri.filtering" href="index.html">otri.filtering</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="otri.filtering.filter.Filter" href="#otri.filtering.filter.Filter">Filter</a></code></h4>
<ul class="">
<li><code><a title="otri.filtering.filter.Filter.execute" href="#otri.filtering.filter.Filter.execute">execute</a></code></li>
<li><code><a title="otri.filtering.filter.Filter.get_input_names" href="#otri.filtering.filter.Filter.get_input_names">get_input_names</a></code></li>
<li><code><a title="otri.filtering.filter.Filter.get_output_names" href="#otri.filtering.filter.Filter.get_output_names">get_output_names</a></code></li>
<li><code><a title="otri.filtering.filter.Filter.setup" href="#otri.filtering.filter.Filter.setup">setup</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.4</a>.</p>
</footer>
</body>
</html>