<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>otri.analysis.convergence API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9;--font-color:#111;--back-color:#eee;--blockquote:#ddd;--code-back:#e5e5e5}.flex{display:flex !important}body{line-height:1.5em;color:var(--font-color);background-color:var(--back-color)}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:500}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:var(--code-back);font-size:.8em;line-height:1.4em}code{padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid var(--blockquote);padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>otri.analysis.convergence</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import functools
from datetime import datetime, timedelta, timezone
from typing import Sequence

from ..filtering.filter import Any, Filter, Mapping
from ..filtering.filter_net import EXEC_AND_PASS, FilterLayer, FilterNet
from ..filtering.filters.align_filter import AlignFilter
from ..filtering.filters.generic_filter import (GenericFilter,
                                                MultipleGenericFiler)
from ..filtering.filters.group_filter import TimeseriesGroupFilter
from ..filtering.filters.threshold_filter import ThresholdFilter
from ..filtering.stream import LocalStream, Stream
from ..utils import key_handler as kh
from ..utils import time_handler as th
from . import Analysis


class RatioFilter(Filter):
    &#39;&#39;&#39;
    Calculates the average ratio between two prices streams every given time group.
    &#39;&#39;&#39;

    def __init__(self, inputs: Sequence[str], outputs: Sequence[str], time_group: timedelta = timedelta(seconds=3600), price_key: str = &#39;close&#39;):
        &#39;&#39;&#39;
        Parameters:\n
            inputs : Sequence[str]
                Input stream names.\n
            outputs : Sequence[str]
                Output stream names.\n
            time_group : timedelta
                After how much time the calculation of the average ratio splits. eg. timedelta(day=1) the filter will return the average ratio for every day.\n
            price_key : str
                Key that contains the price value.\n
        &#39;&#39;&#39;
        super().__init__(
            inputs=inputs,
            outputs=outputs,
            input_count=2,
            output_count=2
        )
        self.__time_group = time_group
        self.__price_key = price_key

    def setup(self, inputs: Sequence[Stream], outputs: Sequence[Stream], state: Mapping[str, Any]):
        # Call superclass setup
        super().setup(inputs, outputs, state)
        self.__state = state
        self.__state[&#39;ratio&#39;] = {}
        self.__atoms = [None, None]
        self.__ratio_sum = 0
        self.__counter = 0
        self.__interval_counter = 0
        self.__interval_atoms_counter = 0
        self.__next_interval = datetime(1, 1, 1, 1, 1, tzinfo=timezone.utc)

    def _on_data(self, data: Any, index: int):
        &#39;&#39;&#39;
        Checks if it received both atoms and calculates the ratio between them.
        It then uses the sum of the ratios to calculate the average ratio for every interval or length time_group.
        &#39;&#39;&#39;
        self.__atoms[index] = data
        # Update atoms counter (for input stream selection)
        self.__counter += 1
        if self.__atoms[0] is not None and self.__atoms[1] is not None:
            # Update interval atoms counter
            self.__interval_atoms_counter += 1
            # Atom ratio
            ratio = float(self.__atoms[0][self.__price_key])/float(self.__atoms[1][self.__price_key])
            # Rate sum
            self.__ratio_sum += ratio
            # Update average ratio
            self.__state[&#39;ratio&#39;][th.datetime_to_str(self.__next_interval)] = self.__ratio_sum/self.__interval_atoms_counter
            # Remove atoms
            self.__atoms[0] = self.__atoms[1] = None

        # Check if it passed the ratio interval
        if th.str_to_datetime(data[&#39;datetime&#39;]) &gt;= self.__next_interval:
            # Reset ratio
            self.__next_interval = th.str_to_datetime(data[&#39;datetime&#39;]) + self.__time_group
            self.__ratio_sum = 0
            self.__interval_counter += 1
            self.__interval_atoms_counter = 0
        self._push_data(data, index=index)

    def _input_check_order(self) -&gt; Sequence[int]:
        &#39;&#39;&#39;
        Defines the order for the inputs to be checked.
        &#39;&#39;&#39;
        return [0] if self.__counter % 2 == 0 else [1]


def ratio_atom_func(avg_ratio: float, elements):
    # Two elements: atom from stream 1 and atom from stream 2
    new_atom = dict()
    new_atom[&#39;close&#39;] = (float(elements[0][&#39;close&#39;])/float(elements[1][&#39;close&#39;]) / avg_ratio) - 1
    return new_atom


class ConvergenceAnalysis(Analysis):
    &#39;&#39;&#39;
    Calculates the ratio between two time series in different periods and returns its value and its variance.
    &#39;&#39;&#39;

    def __init__(self, group_resolution: timedelta = timedelta(hours=4), ratio_interval: timedelta = timedelta(days=1), samples_precision: int = 2):
        &#39;&#39;&#39;
        Parameters:\n
            group_resolution : timedelta
                Resolution to group atoms to. Must be greater than atoms&#39; resolution.\n
            ratio_interval : timedelta
                Interval of time where to calculate the average ratio. Must be greater than group_resolution\n
            samples_precision : int
                Number of decimals of percentage between layers of samples.\n
        &#39;&#39;&#39;
        self.__group_resolution = group_resolution
        self.__ratio_interval = ratio_interval
        self.__samples_step = (10 ** (-samples_precision - 2))

    def execute(self, input_streams: Sequence[Stream]):
        &#39;&#39;&#39;
        Starts convercence analyis.\n

        Parameters:\n
            in_streams : Stream
                Two time series streams to analyise, must contain same-interval atoms with &#39;close&#39; key.
        &#39;&#39;&#39;
        # Prepare output_streams
        output_streams = [LocalStream(), LocalStream()]
        # Calculate ratios ever ratio_interval
        convergence_net = FilterNet(layers=[
            FilterLayer([
                # Tuple extractor
                # TODO: AVOID Tuple-extracting here
                GenericFilter(
                    inputs=&#34;s1&#34;,
                    outputs=&#34;atoms1&#34;,
                    operation=lambda element: element[1]
                ),
                GenericFilter(
                    inputs=&#34;s2&#34;,
                    outputs=&#34;atoms2&#34;,
                    operation=lambda element: element[1]
                )
            ], EXEC_AND_PASS),
            FilterLayer([
                # To Lowercase
                GenericFilter(
                    inputs=&#34;atoms1&#34;,
                    outputs=&#34;lower_s1&#34;,
                    operation=kh.lower_all_keys_deep
                ),
                GenericFilter(
                    inputs=&#34;atoms2&#34;,
                    outputs=&#34;lower_s2&#34;,
                    operation=kh.lower_all_keys_deep
                )
            ], EXEC_AND_PASS),
            FilterLayer([
                # Interpolation
                TimeseriesGroupFilter(
                    inputs=&#34;lower_s1&#34;,
                    outputs=&#34;grouped_s1&#34;,
                    target_resolution=self.__group_resolution
                ),
                TimeseriesGroupFilter(
                    inputs=&#34;lower_s2&#34;,
                    outputs=&#34;grouped_s2&#34;,
                    target_resolution=self.__group_resolution
                )
            ], EXEC_AND_PASS),
            FilterLayer([
                # Align datetime
                AlignFilter(
                    inputs=[&#34;grouped_s1&#34;, &#34;grouped_s2&#34;],
                    outputs=[&#34;align_s1&#34;, &#34;align_s2&#34;]
                )
            ], EXEC_AND_PASS),
            FilterLayer([
                # Rate calc
                RatioFilter(
                    inputs=[&#34;align_s1&#34;, &#34;align_s2&#34;],
                    outputs=[&#34;o1&#34;, &#34;o2&#34;],
                    time_group=self.__ratio_interval
                )
            ], EXEC_AND_PASS)
        ]).execute(source={&#34;s1&#34;: input_streams[0], &#34;s2&#34;: input_streams[1], &#34;o1&#34;: output_streams[0], &#34;o2&#34;: output_streams[1]})

        ratios = convergence_net.state(&#34;ratio&#34;, {})

        # Calculate average ratio
        average_ratio = 0
        for ratio in ratios.values():
            average_ratio += ratio
        if len(ratios) &gt; 0:
            average_ratio /= len(ratios)

        # Calculate variance
        variance = 0
        for ratio in ratios.values():
            variance += (ratio - average_ratio) ** 2
        if len(ratios) &gt; 0:
            variance /= len(ratios)

        # Calculate probability samples

        samples_net = FilterNet(layers=[
            FilterLayer([
                # Rate as atoms
                MultipleGenericFiler(
                    inputs=[&#34;s1&#34;, &#34;s2&#34;],
                    outputs=&#34;ratio&#34;,
                    operation=functools.partial(ratio_atom_func, average_ratio)
                )
            ], EXEC_AND_PASS),
            FilterLayer([
                # Sample density
                ThresholdFilter(
                    inputs=&#34;ratio&#34;,
                    outputs=&#34;o&#34;,
                    price_keys=[&#39;close&#39;],
                    step=lambda i: round(i*self.__samples_step, ndigits=4)
                )
            ], EXEC_AND_PASS)]).execute(source={&#34;s1&#34;: output_streams[0], &#34;s2&#34;: output_streams[1]})

        samples_dict = samples_net.state(key=&#39;thresholds&#39;, default={})

        return {&#34;ratios&#34;: ratios, &#34;average_ratio&#34;: average_ratio, &#34;variance&#34;: variance, &#34;samples&#34;: samples_dict}</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="otri.analysis.convergence.ratio_atom_func"><code class="name flex">
<span>def <span class="ident">ratio_atom_func</span></span>(<span>avg_ratio: float, elements)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ratio_atom_func(avg_ratio: float, elements):
    # Two elements: atom from stream 1 and atom from stream 2
    new_atom = dict()
    new_atom[&#39;close&#39;] = (float(elements[0][&#39;close&#39;])/float(elements[1][&#39;close&#39;]) / avg_ratio) - 1
    return new_atom</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="otri.analysis.convergence.ConvergenceAnalysis"><code class="flex name class">
<span>class <span class="ident">ConvergenceAnalysis</span></span>
<span>(</span><span>group_resolution: datetime.timedelta = datetime.timedelta(seconds=14400), ratio_interval: datetime.timedelta = datetime.timedelta(days=1), samples_precision: int = 2)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates the ratio between two time series in different periods and returns its value and its variance.</p>
<h2 id="parameters">Parameters</h2>
<p>group_resolution : timedelta
Resolution to group atoms to. Must be greater than atoms' resolution.</p>
<p>ratio_interval : timedelta
Interval of time where to calculate the average ratio. Must be greater than group_resolution</p>
<p>samples_precision : int
Number of decimals of percentage between layers of samples.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ConvergenceAnalysis(Analysis):
    &#39;&#39;&#39;
    Calculates the ratio between two time series in different periods and returns its value and its variance.
    &#39;&#39;&#39;

    def __init__(self, group_resolution: timedelta = timedelta(hours=4), ratio_interval: timedelta = timedelta(days=1), samples_precision: int = 2):
        &#39;&#39;&#39;
        Parameters:\n
            group_resolution : timedelta
                Resolution to group atoms to. Must be greater than atoms&#39; resolution.\n
            ratio_interval : timedelta
                Interval of time where to calculate the average ratio. Must be greater than group_resolution\n
            samples_precision : int
                Number of decimals of percentage between layers of samples.\n
        &#39;&#39;&#39;
        self.__group_resolution = group_resolution
        self.__ratio_interval = ratio_interval
        self.__samples_step = (10 ** (-samples_precision - 2))

    def execute(self, input_streams: Sequence[Stream]):
        &#39;&#39;&#39;
        Starts convercence analyis.\n

        Parameters:\n
            in_streams : Stream
                Two time series streams to analyise, must contain same-interval atoms with &#39;close&#39; key.
        &#39;&#39;&#39;
        # Prepare output_streams
        output_streams = [LocalStream(), LocalStream()]
        # Calculate ratios ever ratio_interval
        convergence_net = FilterNet(layers=[
            FilterLayer([
                # Tuple extractor
                # TODO: AVOID Tuple-extracting here
                GenericFilter(
                    inputs=&#34;s1&#34;,
                    outputs=&#34;atoms1&#34;,
                    operation=lambda element: element[1]
                ),
                GenericFilter(
                    inputs=&#34;s2&#34;,
                    outputs=&#34;atoms2&#34;,
                    operation=lambda element: element[1]
                )
            ], EXEC_AND_PASS),
            FilterLayer([
                # To Lowercase
                GenericFilter(
                    inputs=&#34;atoms1&#34;,
                    outputs=&#34;lower_s1&#34;,
                    operation=kh.lower_all_keys_deep
                ),
                GenericFilter(
                    inputs=&#34;atoms2&#34;,
                    outputs=&#34;lower_s2&#34;,
                    operation=kh.lower_all_keys_deep
                )
            ], EXEC_AND_PASS),
            FilterLayer([
                # Interpolation
                TimeseriesGroupFilter(
                    inputs=&#34;lower_s1&#34;,
                    outputs=&#34;grouped_s1&#34;,
                    target_resolution=self.__group_resolution
                ),
                TimeseriesGroupFilter(
                    inputs=&#34;lower_s2&#34;,
                    outputs=&#34;grouped_s2&#34;,
                    target_resolution=self.__group_resolution
                )
            ], EXEC_AND_PASS),
            FilterLayer([
                # Align datetime
                AlignFilter(
                    inputs=[&#34;grouped_s1&#34;, &#34;grouped_s2&#34;],
                    outputs=[&#34;align_s1&#34;, &#34;align_s2&#34;]
                )
            ], EXEC_AND_PASS),
            FilterLayer([
                # Rate calc
                RatioFilter(
                    inputs=[&#34;align_s1&#34;, &#34;align_s2&#34;],
                    outputs=[&#34;o1&#34;, &#34;o2&#34;],
                    time_group=self.__ratio_interval
                )
            ], EXEC_AND_PASS)
        ]).execute(source={&#34;s1&#34;: input_streams[0], &#34;s2&#34;: input_streams[1], &#34;o1&#34;: output_streams[0], &#34;o2&#34;: output_streams[1]})

        ratios = convergence_net.state(&#34;ratio&#34;, {})

        # Calculate average ratio
        average_ratio = 0
        for ratio in ratios.values():
            average_ratio += ratio
        if len(ratios) &gt; 0:
            average_ratio /= len(ratios)

        # Calculate variance
        variance = 0
        for ratio in ratios.values():
            variance += (ratio - average_ratio) ** 2
        if len(ratios) &gt; 0:
            variance /= len(ratios)

        # Calculate probability samples

        samples_net = FilterNet(layers=[
            FilterLayer([
                # Rate as atoms
                MultipleGenericFiler(
                    inputs=[&#34;s1&#34;, &#34;s2&#34;],
                    outputs=&#34;ratio&#34;,
                    operation=functools.partial(ratio_atom_func, average_ratio)
                )
            ], EXEC_AND_PASS),
            FilterLayer([
                # Sample density
                ThresholdFilter(
                    inputs=&#34;ratio&#34;,
                    outputs=&#34;o&#34;,
                    price_keys=[&#39;close&#39;],
                    step=lambda i: round(i*self.__samples_step, ndigits=4)
                )
            ], EXEC_AND_PASS)]).execute(source={&#34;s1&#34;: output_streams[0], &#34;s2&#34;: output_streams[1]})

        samples_dict = samples_net.state(key=&#39;thresholds&#39;, default={})

        return {&#34;ratios&#34;: ratios, &#34;average_ratio&#34;: average_ratio, &#34;variance&#34;: variance, &#34;samples&#34;: samples_dict}</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="otri.analysis.Analysis" href="index.html#otri.analysis.Analysis">Analysis</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="otri.analysis.convergence.ConvergenceAnalysis.execute"><code class="name flex">
<span>def <span class="ident">execute</span></span>(<span>self, input_streams: Sequence[<a title="otri.filtering.stream.Stream" href="../filtering/stream.html#otri.filtering.stream.Stream">Stream</a>])</span>
</code></dt>
<dd>
<div class="desc"><p>Starts convercence analyis.</p>
<h2 id="parameters">Parameters</h2>
<p>in_streams : Stream
Two time series streams to analyise, must contain same-interval atoms with 'close' key.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def execute(self, input_streams: Sequence[Stream]):
    &#39;&#39;&#39;
    Starts convercence analyis.\n

    Parameters:\n
        in_streams : Stream
            Two time series streams to analyise, must contain same-interval atoms with &#39;close&#39; key.
    &#39;&#39;&#39;
    # Prepare output_streams
    output_streams = [LocalStream(), LocalStream()]
    # Calculate ratios ever ratio_interval
    convergence_net = FilterNet(layers=[
        FilterLayer([
            # Tuple extractor
            # TODO: AVOID Tuple-extracting here
            GenericFilter(
                inputs=&#34;s1&#34;,
                outputs=&#34;atoms1&#34;,
                operation=lambda element: element[1]
            ),
            GenericFilter(
                inputs=&#34;s2&#34;,
                outputs=&#34;atoms2&#34;,
                operation=lambda element: element[1]
            )
        ], EXEC_AND_PASS),
        FilterLayer([
            # To Lowercase
            GenericFilter(
                inputs=&#34;atoms1&#34;,
                outputs=&#34;lower_s1&#34;,
                operation=kh.lower_all_keys_deep
            ),
            GenericFilter(
                inputs=&#34;atoms2&#34;,
                outputs=&#34;lower_s2&#34;,
                operation=kh.lower_all_keys_deep
            )
        ], EXEC_AND_PASS),
        FilterLayer([
            # Interpolation
            TimeseriesGroupFilter(
                inputs=&#34;lower_s1&#34;,
                outputs=&#34;grouped_s1&#34;,
                target_resolution=self.__group_resolution
            ),
            TimeseriesGroupFilter(
                inputs=&#34;lower_s2&#34;,
                outputs=&#34;grouped_s2&#34;,
                target_resolution=self.__group_resolution
            )
        ], EXEC_AND_PASS),
        FilterLayer([
            # Align datetime
            AlignFilter(
                inputs=[&#34;grouped_s1&#34;, &#34;grouped_s2&#34;],
                outputs=[&#34;align_s1&#34;, &#34;align_s2&#34;]
            )
        ], EXEC_AND_PASS),
        FilterLayer([
            # Rate calc
            RatioFilter(
                inputs=[&#34;align_s1&#34;, &#34;align_s2&#34;],
                outputs=[&#34;o1&#34;, &#34;o2&#34;],
                time_group=self.__ratio_interval
            )
        ], EXEC_AND_PASS)
    ]).execute(source={&#34;s1&#34;: input_streams[0], &#34;s2&#34;: input_streams[1], &#34;o1&#34;: output_streams[0], &#34;o2&#34;: output_streams[1]})

    ratios = convergence_net.state(&#34;ratio&#34;, {})

    # Calculate average ratio
    average_ratio = 0
    for ratio in ratios.values():
        average_ratio += ratio
    if len(ratios) &gt; 0:
        average_ratio /= len(ratios)

    # Calculate variance
    variance = 0
    for ratio in ratios.values():
        variance += (ratio - average_ratio) ** 2
    if len(ratios) &gt; 0:
        variance /= len(ratios)

    # Calculate probability samples

    samples_net = FilterNet(layers=[
        FilterLayer([
            # Rate as atoms
            MultipleGenericFiler(
                inputs=[&#34;s1&#34;, &#34;s2&#34;],
                outputs=&#34;ratio&#34;,
                operation=functools.partial(ratio_atom_func, average_ratio)
            )
        ], EXEC_AND_PASS),
        FilterLayer([
            # Sample density
            ThresholdFilter(
                inputs=&#34;ratio&#34;,
                outputs=&#34;o&#34;,
                price_keys=[&#39;close&#39;],
                step=lambda i: round(i*self.__samples_step, ndigits=4)
            )
        ], EXEC_AND_PASS)]).execute(source={&#34;s1&#34;: output_streams[0], &#34;s2&#34;: output_streams[1]})

    samples_dict = samples_net.state(key=&#39;thresholds&#39;, default={})

    return {&#34;ratios&#34;: ratios, &#34;average_ratio&#34;: average_ratio, &#34;variance&#34;: variance, &#34;samples&#34;: samples_dict}</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="otri.analysis.convergence.RatioFilter"><code class="flex name class">
<span>class <span class="ident">RatioFilter</span></span>
<span>(</span><span>inputs: Sequence[str], outputs: Sequence[str], time_group: datetime.timedelta = datetime.timedelta(seconds=3600), price_key: str = 'close')</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates the average ratio between two prices streams every given time group.</p>
<h2 id="parameters">Parameters</h2>
<p>inputs : Sequence[str]
Input stream names.</p>
<p>outputs : Sequence[str]
Output stream names.</p>
<p>time_group : timedelta
After how much time the calculation of the average ratio splits. eg. timedelta(day=1) the filter will return the average ratio for every day.</p>
<p>price_key : str
Key that contains the price value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RatioFilter(Filter):
    &#39;&#39;&#39;
    Calculates the average ratio between two prices streams every given time group.
    &#39;&#39;&#39;

    def __init__(self, inputs: Sequence[str], outputs: Sequence[str], time_group: timedelta = timedelta(seconds=3600), price_key: str = &#39;close&#39;):
        &#39;&#39;&#39;
        Parameters:\n
            inputs : Sequence[str]
                Input stream names.\n
            outputs : Sequence[str]
                Output stream names.\n
            time_group : timedelta
                After how much time the calculation of the average ratio splits. eg. timedelta(day=1) the filter will return the average ratio for every day.\n
            price_key : str
                Key that contains the price value.\n
        &#39;&#39;&#39;
        super().__init__(
            inputs=inputs,
            outputs=outputs,
            input_count=2,
            output_count=2
        )
        self.__time_group = time_group
        self.__price_key = price_key

    def setup(self, inputs: Sequence[Stream], outputs: Sequence[Stream], state: Mapping[str, Any]):
        # Call superclass setup
        super().setup(inputs, outputs, state)
        self.__state = state
        self.__state[&#39;ratio&#39;] = {}
        self.__atoms = [None, None]
        self.__ratio_sum = 0
        self.__counter = 0
        self.__interval_counter = 0
        self.__interval_atoms_counter = 0
        self.__next_interval = datetime(1, 1, 1, 1, 1, tzinfo=timezone.utc)

    def _on_data(self, data: Any, index: int):
        &#39;&#39;&#39;
        Checks if it received both atoms and calculates the ratio between them.
        It then uses the sum of the ratios to calculate the average ratio for every interval or length time_group.
        &#39;&#39;&#39;
        self.__atoms[index] = data
        # Update atoms counter (for input stream selection)
        self.__counter += 1
        if self.__atoms[0] is not None and self.__atoms[1] is not None:
            # Update interval atoms counter
            self.__interval_atoms_counter += 1
            # Atom ratio
            ratio = float(self.__atoms[0][self.__price_key])/float(self.__atoms[1][self.__price_key])
            # Rate sum
            self.__ratio_sum += ratio
            # Update average ratio
            self.__state[&#39;ratio&#39;][th.datetime_to_str(self.__next_interval)] = self.__ratio_sum/self.__interval_atoms_counter
            # Remove atoms
            self.__atoms[0] = self.__atoms[1] = None

        # Check if it passed the ratio interval
        if th.str_to_datetime(data[&#39;datetime&#39;]) &gt;= self.__next_interval:
            # Reset ratio
            self.__next_interval = th.str_to_datetime(data[&#39;datetime&#39;]) + self.__time_group
            self.__ratio_sum = 0
            self.__interval_counter += 1
            self.__interval_atoms_counter = 0
        self._push_data(data, index=index)

    def _input_check_order(self) -&gt; Sequence[int]:
        &#39;&#39;&#39;
        Defines the order for the inputs to be checked.
        &#39;&#39;&#39;
        return [0] if self.__counter % 2 == 0 else [1]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="otri.filtering.filter.Filter" href="../filtering/filter.html#otri.filtering.filter.Filter">Filter</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="otri.analysis.convergence.RatioFilter.execute"><code class="name flex">
<span>def <span class="ident">execute</span></span>(<span>self)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="otri.filtering.filter.Filter" href="../filtering/filter.html#otri.filtering.filter.Filter">Filter</a></code>.<code><a title="otri.filtering.filter.Filter.execute" href="../filtering/filter.html#otri.filtering.filter.Filter.execute">execute</a></code>
</p>
<div class="desc inherited"><p>This method gets called by the FilterNet when the filter has to manipulate data.
It should:
- Pop a single piece of data from one of the input …</p></div>
</dd>
<dt id="otri.analysis.convergence.RatioFilter.setup"><code class="name flex">
<span>def <span class="ident">setup</span></span>(<span>self, inputs: Sequence[<a title="otri.filtering.stream.Stream" href="../filtering/stream.html#otri.filtering.stream.Stream">Stream</a>], outputs: Sequence[<a title="otri.filtering.stream.Stream" href="../filtering/stream.html#otri.filtering.stream.Stream">Stream</a>], state: Mapping[str, Any])</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="otri.filtering.filter.Filter" href="../filtering/filter.html#otri.filtering.filter.Filter">Filter</a></code>.<code><a title="otri.filtering.filter.Filter.setup" href="../filtering/filter.html#otri.filtering.filter.Filter.setup">setup</a></code>
</p>
<div class="desc inherited"><p>Allows the filter to save references to streams and reset its variables before the execution.</p>
<h2 id="parameters">Parameters</h2>
<p>inputs, outputs : Sequence[Stream]
…</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setup(self, inputs: Sequence[Stream], outputs: Sequence[Stream], state: Mapping[str, Any]):
    # Call superclass setup
    super().setup(inputs, outputs, state)
    self.__state = state
    self.__state[&#39;ratio&#39;] = {}
    self.__atoms = [None, None]
    self.__ratio_sum = 0
    self.__counter = 0
    self.__interval_counter = 0
    self.__interval_atoms_counter = 0
    self.__next_interval = datetime(1, 1, 1, 1, 1, tzinfo=timezone.utc)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="otri.analysis" href="index.html">otri.analysis</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="otri.analysis.convergence.ratio_atom_func" href="#otri.analysis.convergence.ratio_atom_func">ratio_atom_func</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="otri.analysis.convergence.ConvergenceAnalysis" href="#otri.analysis.convergence.ConvergenceAnalysis">ConvergenceAnalysis</a></code></h4>
<ul class="">
<li><code><a title="otri.analysis.convergence.ConvergenceAnalysis.execute" href="#otri.analysis.convergence.ConvergenceAnalysis.execute">execute</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="otri.analysis.convergence.RatioFilter" href="#otri.analysis.convergence.RatioFilter">RatioFilter</a></code></h4>
<ul class="">
<li><code><a title="otri.analysis.convergence.RatioFilter.execute" href="../filtering/filter.html#otri.analysis.convergence.RatioFilter.execute">execute</a></code></li>
<li><code><a title="otri.analysis.convergence.RatioFilter.setup" href="#otri.analysis.convergence.RatioFilter.setup">setup</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>