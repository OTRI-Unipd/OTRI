<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>otri.utils.key_handler API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9;--font-color:#111;--back-color:#eee;--blockquote:#ddd;--code-back:#e5e5e5}.flex{display:flex !important}body{line-height:1.5em;color:var(--font-color);background-color:var(--back-color)}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:500}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:var(--code-back);font-size:.8em;line-height:1.4em}code{padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid var(--blockquote);padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>otri.utils.key_handler</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from typing import Mapping, List, Callable, Union
import re

LOWER_ERROR = &#34;Only dictionaries and lists can be modified by this method.&#34;


def apply_deep(data: Union[Mapping, List], fun: Callable) -&gt; Union[dict, list]:
    &#39;&#39;&#39;
    Applies fun to all keys in data.
    The method is recursive and applies as deep as possible in the dictionary nest.

    Parameters:
        data : Mapping | List
            Data to modify, must be either a dictionary or a list of dictionaries.
        fun : function | lambda
            Function to apply to each key, must take the key as its single parameter.
    Returns:
        A copy of the dict or list with the modified keys, with all nested dicts and list
        receiving the same treatment. It will return the original
        object (not a copy) if no operation could be applied, for example when:
        - data is not a list or dict
        - data is a list of non dict items
        - data is not a list that contains dicts at any nesting level
        ...
    &#39;&#39;&#39;
    if isinstance(data, Mapping):
        return __apply_deep_dict(data, fun)
    if isinstance(data, List):
        return __apply_deep_list(data, fun)
    return data


def __apply_deep_dict(data: Mapping, fun: Callable) -&gt; dict:
    &#39;&#39;&#39;
    Applies fun to all keys in a dictionary and all nested items.

    Parameters:
        data : dict
            Data to modify, must be a dictionary.
        fun : function | lambda
            Function to apply to each key, must take the key as its single parameter.
    Returns:
        A copy of the dict with the renamed keys, where all values have been replaced by copies of
        their original if apply_deep(value, fun) was appliable.
    &#39;&#39;&#39;
    new_data = dict()
    for key, value in data.items():
        new_key = fun(key)
        new_data[new_key] = apply_deep(value, fun)
    return new_data


def __apply_deep_list(data: List, fun: Callable) -&gt; list:
    &#39;&#39;&#39;
    Applies fun to all keys in each item of the list, if appliable.

    Parameters:
        data : List
            Data to modify, should be a list, but can be a tuple.
        fun : function | lambda
            Function to apply to each key, must take the key as its single parameter.
    Returns:
        A copy of the list, where each item got its keys modified through apply_deep(item, fun) if appliable.
    &#39;&#39;&#39;
    return [apply_deep(item, fun) for item in data]


def apply_deep_values(data: Union[Mapping, List], fun: Callable) -&gt; Union[dict, list]:
    &#39;&#39;&#39;
    Applies fun to all values in data.
    The method is recursive and applies as deep as possible in the dictionary nest. 

    Parameters:
        data : Mapping or List
            Data to modify, must be either a dictionary or a list of dictionaries.
        fun : function | lambda
            Function to apply to each key, must take the key as its single parameter.
    Returns:
        A copy of the dict or list with the modified keys, with all nested dicts and list
        receiving the same treatment. It will return the original
        object (not a copy) if no operation could be applied, for example when:
        - data is not a list or dict
        - data is a list of non dict items
        - data is not a list that contains dicts at any nesting level
        ...
    &#39;&#39;&#39;
    if isinstance(data, Mapping):
        return __apply_deep_values_dict(data, fun)
    if isinstance(data, List):
        return __apply_deep_values_list(data, fun)
    return data


def __apply_deep_values_dict(data: Mapping, fun: Callable) -&gt; dict:
    &#39;&#39;&#39;
    Applies fun to all keys in a dictionary and all nested items.

    Parameters:
        data : dict
            Data to modify, must be a dictionary.
        fun : function | lambda
            Function to apply to each key, must take the key as its single parameter.
    Returns:
        A copy of the dict with the renamed keys, where all values have been replaced by copies of
        their original if apply_deep(value, fun) was appliable.
    &#39;&#39;&#39;
    new_data = dict()
    for key, value in data.items():
        new_value = fun(value)
        new_data[key] = apply_deep_values(new_value, fun)
    return new_data


def __apply_deep_values_list(data: List, fun: Callable) -&gt; list:
    &#39;&#39;&#39;
    Applies fun to all values in each item of the list, if appliable.

    Parameters:
        data : List
            Data to modify, should be a list, but can be a tuple.
        fun : function | lambda
            Function to apply to each key, must take the key as its single parameter.
    Returns:
        A copy of the list, where each item got its keys modified through apply_deep(item, fun) if appliable.
    &#39;&#39;&#39;
    return [apply_deep_values(item, fun) for item in data]


def lower_all_keys_deep(data: Union[Mapping, List]) -&gt; Union[dict, list]:
    &#39;&#39;&#39;
    Renames all the keys in a dict object to be lower case.
    The method is recursive and applies as deep as possible in the dict nest. 

    Parameters:
        data : dict | list
            Data to modify, must be either a dictionary or a list of dictionaries.
            Should work with any dictionary. In any case, only string keys will be modified.
    Returns:
        A copy of the dict or list with the renamed keys, with all nested dicts and list
        receiving the same treatment. It will return the original
        object (not a copy) if no operation could be applied. See apply_deep(data, fun) for details.
        ...
    &#39;&#39;&#39;
    return apply_deep(data, lambda s: s.lower() if isinstance(s, str) else s)


def rename_deep(data: Union[Mapping, List], aliases: Mapping) -&gt; Union[dict, list]:
    &#39;&#39;&#39;
    Renames the keys in the dict object based on the aliases in dict.
    The method is recursive and applies as deep as possible in the dict nest.
    es. data = {&#34;key&#34; : &#34;value&#34;}, aliases {&#34;key&#34; : &#34;one&#34;}
    data becomes {&#34;one&#34; : &#34;value&#34;}

    Parameters:
        data : dict | list
            Data to modify, must be either a dictionary or a list of dictionaries.
            Should work with any dictionary.
        aliases : dict
            Dictionary containing the aliases for the keys. For each item the key must be
            the original key and the value the new key. Keys of any type will be modified
            as long as they are a key in aliases.
    Returns:
        A copy of the dict or list with the renamed keys, with all nested dicts and list
        receiving the same treatment. It will return the original
        object (not a copy) if no operation could be applied. See apply_deep(data, fun) for details.
    &#39;&#39;&#39;
    return apply_deep(data, lambda x: aliases[x] if x in aliases.keys() else x)


def rename_shallow(data: Union[Mapping, List], aliases: Mapping) -&gt; Union[Mapping, List]:
    &#39;&#39;&#39;
    Renames the key in the dict or list based on the aliases in dict.
    The method only checks the first &#34;layer&#34; of keys, without going deeper.
    &#39;&#39;&#39;
    if isinstance(data, List):
        return [__rename_dict(element, aliases) for element in data]
    return __rename_dict(data, aliases)


def __rename_dict(data: Mapping, aliases: Mapping) -&gt; Mapping:
    &#39;&#39;&#39;
    Renames the key of a dict
    &#39;&#39;&#39;
    for key in aliases:
        if data.get(key, None) is not None:
            data[aliases[key]] = data[key]
            del data[key]
    return data


def replace_deep(data: Union[Mapping, List], regexes: Mapping) -&gt; Union[dict, list]:
    &#39;&#39;&#39;
    Renames the keys in a dictionary replacing each given regex with the given alias.
    The method is recursive and applies as deep as possible in the dict nest.
    es. data = {&#34;key_ciao&#34; : &#34;value&#34;}, aliases {&#34;ciao&#34; : &#34;hi&#34;}
    data becomes {&#34;key_hi&#34; : &#34;value&#34;}

    Parameters:
        data : dict | list
            Data to modify, must be either a dictionary or a list of dictionaries.
            Should work with any dictionary.
        aliases : dict
            Dictionary containing the aliases for the keys. For each item the key must be
            the regex to replace and the value what to replace it with.
            Only string keys are modified.
    Returns:
        A copy of the dict or list with the renamed keys, with all nested dicts and lists
        receiving the same treatment. It will return the original object (not a copy)
        if no operation could be applied. See apply_deep(data, fun) for details.
    &#39;&#39;&#39;
    def replace_regex(string, regexes=regexes):
        for r, s in regexes.items():
            string = re.sub(r, s, string)
        return string
    return apply_deep(data, lambda x: replace_regex(x) if isinstance(x, str) else x)


def round_deep(data: Union[Mapping, List], digits: int = 3) -&gt; Union[dict, list]:
    &#39;&#39;&#39;
    Rounds all values float numbers to the least digits as possibile for a maximum of the &#34;digits&#34; parameter.

    Parameters:
        data : dict | list
            Data to modify, must be either a dictionary or a list of dictionaries.
            Should work with any dictionary.
        digits : int
            Number of maximum digits for the rounded value.

    Returns:
        A copy of the dict or list with the rounded or cut float digits.
    &#39;&#39;&#39;

    def round_op(string, digits=digits):
        try:
            number = float(string)
            rounded_number = round(number, ndigits=digits)
            return rounded_number
        except ValueError:
            return string
    return apply_deep_values(data, lambda x: round_op(x) if isinstance(x, float) else x)


def round_shallow(data: Mapping, keys: List, digits: int = 3) -&gt; Mapping:
    &#39;&#39;&#39;
    Rounds the passed keys&#39; values of the dict or list to a certain digit.
    The method only checks the first &#34;layer&#34; of keys, without going deeper.
    All keys&#39; values must be numbers.

    Raises:
        TypeError if one of the given key is not a float
        KeyError if one of the give key is not in data
    &#39;&#39;&#39;
    if isinstance(data, List):
        return [__round_shallow_dict(element, keys, digits) for element in data]
    return __round_shallow_dict(data, keys, digits)


def __round_shallow_dict(data: Mapping, keys: List, digits: int = 3) -&gt; Mapping:
    for key in keys:
        try:
            data[key] = round(float(data[key]), ndigits=digits)
        except KeyError:
            continue
        except TypeError:
            # In case the key is not a number (usually None), just remove the key from the atom
            del data[key]
    return data</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="otri.utils.key_handler.apply_deep"><code class="name flex">
<span>def <span class="ident">apply_deep</span></span>(<span>data: Union[Mapping, List], fun: Callable) ‑> Union[dict, list]</span>
</code></dt>
<dd>
<div class="desc"><p>Applies fun to all keys in data.
The method is recursive and applies as deep as possible in the dictionary nest.</p>
<h2 id="parameters">Parameters</h2>
<p>data : Mapping | List
Data to modify, must be either a dictionary or a list of dictionaries.
fun : function | lambda
Function to apply to each key, must take the key as its single parameter.</p>
<h2 id="returns">Returns</h2>
<p>A copy of the dict or list with the modified keys, with all nested dicts and list
receiving the same treatment. It will return the original
object (not a copy) if no operation could be applied, for example when:
- data is not a list or dict
- data is a list of non dict items
- data is not a list that contains dicts at any nesting level
&hellip;</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply_deep(data: Union[Mapping, List], fun: Callable) -&gt; Union[dict, list]:
    &#39;&#39;&#39;
    Applies fun to all keys in data.
    The method is recursive and applies as deep as possible in the dictionary nest.

    Parameters:
        data : Mapping | List
            Data to modify, must be either a dictionary or a list of dictionaries.
        fun : function | lambda
            Function to apply to each key, must take the key as its single parameter.
    Returns:
        A copy of the dict or list with the modified keys, with all nested dicts and list
        receiving the same treatment. It will return the original
        object (not a copy) if no operation could be applied, for example when:
        - data is not a list or dict
        - data is a list of non dict items
        - data is not a list that contains dicts at any nesting level
        ...
    &#39;&#39;&#39;
    if isinstance(data, Mapping):
        return __apply_deep_dict(data, fun)
    if isinstance(data, List):
        return __apply_deep_list(data, fun)
    return data</code></pre>
</details>
</dd>
<dt id="otri.utils.key_handler.apply_deep_values"><code class="name flex">
<span>def <span class="ident">apply_deep_values</span></span>(<span>data: Union[Mapping, List], fun: Callable) ‑> Union[dict, list]</span>
</code></dt>
<dd>
<div class="desc"><p>Applies fun to all values in data.
The method is recursive and applies as deep as possible in the dictionary nest. </p>
<h2 id="parameters">Parameters</h2>
<p>data : Mapping or List
Data to modify, must be either a dictionary or a list of dictionaries.
fun : function | lambda
Function to apply to each key, must take the key as its single parameter.</p>
<h2 id="returns">Returns</h2>
<p>A copy of the dict or list with the modified keys, with all nested dicts and list
receiving the same treatment. It will return the original
object (not a copy) if no operation could be applied, for example when:
- data is not a list or dict
- data is a list of non dict items
- data is not a list that contains dicts at any nesting level
&hellip;</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply_deep_values(data: Union[Mapping, List], fun: Callable) -&gt; Union[dict, list]:
    &#39;&#39;&#39;
    Applies fun to all values in data.
    The method is recursive and applies as deep as possible in the dictionary nest. 

    Parameters:
        data : Mapping or List
            Data to modify, must be either a dictionary or a list of dictionaries.
        fun : function | lambda
            Function to apply to each key, must take the key as its single parameter.
    Returns:
        A copy of the dict or list with the modified keys, with all nested dicts and list
        receiving the same treatment. It will return the original
        object (not a copy) if no operation could be applied, for example when:
        - data is not a list or dict
        - data is a list of non dict items
        - data is not a list that contains dicts at any nesting level
        ...
    &#39;&#39;&#39;
    if isinstance(data, Mapping):
        return __apply_deep_values_dict(data, fun)
    if isinstance(data, List):
        return __apply_deep_values_list(data, fun)
    return data</code></pre>
</details>
</dd>
<dt id="otri.utils.key_handler.lower_all_keys_deep"><code class="name flex">
<span>def <span class="ident">lower_all_keys_deep</span></span>(<span>data: Union[Mapping, List]) ‑> Union[dict, list]</span>
</code></dt>
<dd>
<div class="desc"><p>Renames all the keys in a dict object to be lower case.
The method is recursive and applies as deep as possible in the dict nest. </p>
<h2 id="parameters">Parameters</h2>
<p>data : dict | list
Data to modify, must be either a dictionary or a list of dictionaries.
Should work with any dictionary. In any case, only string keys will be modified.</p>
<h2 id="returns">Returns</h2>
<p>A copy of the dict or list with the renamed keys, with all nested dicts and list
receiving the same treatment. It will return the original
object (not a copy) if no operation could be applied. See apply_deep(data, fun) for details.
&hellip;</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lower_all_keys_deep(data: Union[Mapping, List]) -&gt; Union[dict, list]:
    &#39;&#39;&#39;
    Renames all the keys in a dict object to be lower case.
    The method is recursive and applies as deep as possible in the dict nest. 

    Parameters:
        data : dict | list
            Data to modify, must be either a dictionary or a list of dictionaries.
            Should work with any dictionary. In any case, only string keys will be modified.
    Returns:
        A copy of the dict or list with the renamed keys, with all nested dicts and list
        receiving the same treatment. It will return the original
        object (not a copy) if no operation could be applied. See apply_deep(data, fun) for details.
        ...
    &#39;&#39;&#39;
    return apply_deep(data, lambda s: s.lower() if isinstance(s, str) else s)</code></pre>
</details>
</dd>
<dt id="otri.utils.key_handler.rename_deep"><code class="name flex">
<span>def <span class="ident">rename_deep</span></span>(<span>data: Union[Mapping, List], aliases: Mapping) ‑> Union[dict, list]</span>
</code></dt>
<dd>
<div class="desc"><p>Renames the keys in the dict object based on the aliases in dict.
The method is recursive and applies as deep as possible in the dict nest.
es. data = {"key" : "value"}, aliases {"key" : "one"}
data becomes {"one" : "value"}</p>
<h2 id="parameters">Parameters</h2>
<p>data : dict | list
Data to modify, must be either a dictionary or a list of dictionaries.
Should work with any dictionary.
aliases : dict
Dictionary containing the aliases for the keys. For each item the key must be
the original key and the value the new key. Keys of any type will be modified
as long as they are a key in aliases.</p>
<h2 id="returns">Returns</h2>
<p>A copy of the dict or list with the renamed keys, with all nested dicts and list
receiving the same treatment. It will return the original
object (not a copy) if no operation could be applied. See apply_deep(data, fun) for details.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rename_deep(data: Union[Mapping, List], aliases: Mapping) -&gt; Union[dict, list]:
    &#39;&#39;&#39;
    Renames the keys in the dict object based on the aliases in dict.
    The method is recursive and applies as deep as possible in the dict nest.
    es. data = {&#34;key&#34; : &#34;value&#34;}, aliases {&#34;key&#34; : &#34;one&#34;}
    data becomes {&#34;one&#34; : &#34;value&#34;}

    Parameters:
        data : dict | list
            Data to modify, must be either a dictionary or a list of dictionaries.
            Should work with any dictionary.
        aliases : dict
            Dictionary containing the aliases for the keys. For each item the key must be
            the original key and the value the new key. Keys of any type will be modified
            as long as they are a key in aliases.
    Returns:
        A copy of the dict or list with the renamed keys, with all nested dicts and list
        receiving the same treatment. It will return the original
        object (not a copy) if no operation could be applied. See apply_deep(data, fun) for details.
    &#39;&#39;&#39;
    return apply_deep(data, lambda x: aliases[x] if x in aliases.keys() else x)</code></pre>
</details>
</dd>
<dt id="otri.utils.key_handler.rename_shallow"><code class="name flex">
<span>def <span class="ident">rename_shallow</span></span>(<span>data: Union[Mapping, List], aliases: Mapping) ‑> Union[Mapping, List]</span>
</code></dt>
<dd>
<div class="desc"><p>Renames the key in the dict or list based on the aliases in dict.
The method only checks the first "layer" of keys, without going deeper.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rename_shallow(data: Union[Mapping, List], aliases: Mapping) -&gt; Union[Mapping, List]:
    &#39;&#39;&#39;
    Renames the key in the dict or list based on the aliases in dict.
    The method only checks the first &#34;layer&#34; of keys, without going deeper.
    &#39;&#39;&#39;
    if isinstance(data, List):
        return [__rename_dict(element, aliases) for element in data]
    return __rename_dict(data, aliases)</code></pre>
</details>
</dd>
<dt id="otri.utils.key_handler.replace_deep"><code class="name flex">
<span>def <span class="ident">replace_deep</span></span>(<span>data: Union[Mapping, List], regexes: Mapping) ‑> Union[dict, list]</span>
</code></dt>
<dd>
<div class="desc"><p>Renames the keys in a dictionary replacing each given regex with the given alias.
The method is recursive and applies as deep as possible in the dict nest.
es. data = {"key_ciao" : "value"}, aliases {"ciao" : "hi"}
data becomes {"key_hi" : "value"}</p>
<h2 id="parameters">Parameters</h2>
<p>data : dict | list
Data to modify, must be either a dictionary or a list of dictionaries.
Should work with any dictionary.
aliases : dict
Dictionary containing the aliases for the keys. For each item the key must be
the regex to replace and the value what to replace it with.
Only string keys are modified.</p>
<h2 id="returns">Returns</h2>
<p>A copy of the dict or list with the renamed keys, with all nested dicts and lists
receiving the same treatment. It will return the original object (not a copy)
if no operation could be applied. See apply_deep(data, fun) for details.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def replace_deep(data: Union[Mapping, List], regexes: Mapping) -&gt; Union[dict, list]:
    &#39;&#39;&#39;
    Renames the keys in a dictionary replacing each given regex with the given alias.
    The method is recursive and applies as deep as possible in the dict nest.
    es. data = {&#34;key_ciao&#34; : &#34;value&#34;}, aliases {&#34;ciao&#34; : &#34;hi&#34;}
    data becomes {&#34;key_hi&#34; : &#34;value&#34;}

    Parameters:
        data : dict | list
            Data to modify, must be either a dictionary or a list of dictionaries.
            Should work with any dictionary.
        aliases : dict
            Dictionary containing the aliases for the keys. For each item the key must be
            the regex to replace and the value what to replace it with.
            Only string keys are modified.
    Returns:
        A copy of the dict or list with the renamed keys, with all nested dicts and lists
        receiving the same treatment. It will return the original object (not a copy)
        if no operation could be applied. See apply_deep(data, fun) for details.
    &#39;&#39;&#39;
    def replace_regex(string, regexes=regexes):
        for r, s in regexes.items():
            string = re.sub(r, s, string)
        return string
    return apply_deep(data, lambda x: replace_regex(x) if isinstance(x, str) else x)</code></pre>
</details>
</dd>
<dt id="otri.utils.key_handler.round_deep"><code class="name flex">
<span>def <span class="ident">round_deep</span></span>(<span>data: Union[Mapping, List], digits: int = 3) ‑> Union[dict, list]</span>
</code></dt>
<dd>
<div class="desc"><p>Rounds all values float numbers to the least digits as possibile for a maximum of the "digits" parameter.</p>
<h2 id="parameters">Parameters</h2>
<p>data : dict | list
Data to modify, must be either a dictionary or a list of dictionaries.
Should work with any dictionary.
digits : int
Number of maximum digits for the rounded value.</p>
<h2 id="returns">Returns</h2>
<p>A copy of the dict or list with the rounded or cut float digits.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def round_deep(data: Union[Mapping, List], digits: int = 3) -&gt; Union[dict, list]:
    &#39;&#39;&#39;
    Rounds all values float numbers to the least digits as possibile for a maximum of the &#34;digits&#34; parameter.

    Parameters:
        data : dict | list
            Data to modify, must be either a dictionary or a list of dictionaries.
            Should work with any dictionary.
        digits : int
            Number of maximum digits for the rounded value.

    Returns:
        A copy of the dict or list with the rounded or cut float digits.
    &#39;&#39;&#39;

    def round_op(string, digits=digits):
        try:
            number = float(string)
            rounded_number = round(number, ndigits=digits)
            return rounded_number
        except ValueError:
            return string
    return apply_deep_values(data, lambda x: round_op(x) if isinstance(x, float) else x)</code></pre>
</details>
</dd>
<dt id="otri.utils.key_handler.round_shallow"><code class="name flex">
<span>def <span class="ident">round_shallow</span></span>(<span>data: Mapping, keys: List, digits: int = 3) ‑> Mapping</span>
</code></dt>
<dd>
<div class="desc"><p>Rounds the passed keys' values of the dict or list to a certain digit.
The method only checks the first "layer" of keys, without going deeper.
All keys' values must be numbers.</p>
<h2 id="raises">Raises</h2>
<p>TypeError if one of the given key is not a float
KeyError if one of the give key is not in data</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def round_shallow(data: Mapping, keys: List, digits: int = 3) -&gt; Mapping:
    &#39;&#39;&#39;
    Rounds the passed keys&#39; values of the dict or list to a certain digit.
    The method only checks the first &#34;layer&#34; of keys, without going deeper.
    All keys&#39; values must be numbers.

    Raises:
        TypeError if one of the given key is not a float
        KeyError if one of the give key is not in data
    &#39;&#39;&#39;
    if isinstance(data, List):
        return [__round_shallow_dict(element, keys, digits) for element in data]
    return __round_shallow_dict(data, keys, digits)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="otri.utils" href="index.html">otri.utils</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="otri.utils.key_handler.apply_deep" href="#otri.utils.key_handler.apply_deep">apply_deep</a></code></li>
<li><code><a title="otri.utils.key_handler.apply_deep_values" href="#otri.utils.key_handler.apply_deep_values">apply_deep_values</a></code></li>
<li><code><a title="otri.utils.key_handler.lower_all_keys_deep" href="#otri.utils.key_handler.lower_all_keys_deep">lower_all_keys_deep</a></code></li>
<li><code><a title="otri.utils.key_handler.rename_deep" href="#otri.utils.key_handler.rename_deep">rename_deep</a></code></li>
<li><code><a title="otri.utils.key_handler.rename_shallow" href="#otri.utils.key_handler.rename_shallow">rename_shallow</a></code></li>
<li><code><a title="otri.utils.key_handler.replace_deep" href="#otri.utils.key_handler.replace_deep">replace_deep</a></code></li>
<li><code><a title="otri.utils.key_handler.round_deep" href="#otri.utils.key_handler.round_deep">round_deep</a></code></li>
<li><code><a title="otri.utils.key_handler.round_shallow" href="#otri.utils.key_handler.round_shallow">round_shallow</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>