'''
Module that contains a wrapper for Tradier.com available data downloading.
'''

__autor__ = "Luca Crema <lc.crema@hotmail.com>"
__version__ = "1.0"

import queue
import time
from typing import Sequence, Union
import requests

from otri.utils import logger as log, time_handler as th, key_handler

from . import RealtimeDownloader, ATOMS_KEY, METADATA_KEY, META_KEY_PROVIDER, META_RT_VALUE_TYPE, META_KEY_TYPE, META_KEY_DOWNLOAD_DT


META_VALUE_PROVIDER = "tradier"
BASE_URL = "https://sandbox.tradier.com/v1/"


class TradierRealtime(RealtimeDownloader):
    '''
    Downloads realtime data by querying the provider multiple times.
    '''

    ALIASES = {
        "symbol": "ticker",
        "exch": "exchange",
        "bidexch": "bid_exchange",
        "askexch": "ask_exchange"
    }

    VALUABLE = [
        "symbol",
        "exch",
        "last",
        "volume",
        "bid",
        "ask",
        "last_volume",
        "trade_date",
        "bidsize",
        "bidexch",
        "bid_date",
        "asksize",
        "askexch",
        "ask_date"
    ]

    EXCHANGES = {
        "A": "NYSE MKT",
        "B": "NASDAQ OMX BX",
        "C": "National Stock Exchange",
        "D": "FINRA ADF",
        "E": "Market Independent(Generated by Nasdaq SIP)",
        "F": "Mutual Funds/Money Markets(NASDAQ)",
        "I": "International Securities Exchange",
        "J": "Direct Edge A",
        "K": "Direct Edge X",
        "M": "Chicago Stock Exchange",
        "N": "NYSE",
        "P": "NYSE Arca",
        "Q": "NASDAQ OMX",
        "S": "NASDAQ Small Cap",
        "T": "NASDAQ Int",
        "U": "OTCBB",
        "V": "OTC other",
        "W": "CBOE",
        "X": "NASDAQ OMX PSX",
        "G": "GLOBEX",
        "Y": "BATS Y-Exchange",
        "Z": "BATS"
    }

    # Necessary keys to consider the atom valid, if all of them is 0 we can discard the atom
    NECESSARY = [
        "volume",
        "bid",
        "ask",
        "last",
        "last_volume"
    ]

    def __init__(self, key: str):
        '''
        Parameters:\n
            key : str
                Sandbox user key.
        '''
        self.key = key

    def start(self, tickers: Union[str, Sequence[str]], period: float, contents_queue: queue.Queue):
        '''
        Starts the download of the ticker/tickers data.\n

        Parameters:\n
            tickers : Sequence[str]
                List of tickers to download per request. Must be less than 1000 elements.\n
            period : float
                Minimum time between successive requests.\n
            contents_queue : queue.Queue
                Data structure where atoms will be placed asyncronously when downloaded and processed.
        '''
        if isinstance(tickers, str):
            tickers = [tickers]

        str_tickers = self.__str_tickers(tickers)
        self.execute = True
        # Start download
        while(self.execute):
            start_time = time.time()
            response = requests.get(BASE_URL + 'markets/quotes',
                                    params={'symbols': str_tickers, 'greeks': 'false'},
                                    headers={'Authorization': 'Bearer ' + self.key, 'Accept': 'application/json'}
                                    )
            if response.status_code == 200:
                # Prepare data
                json_response = TradierRealtime.__prepare_data(response.json())
                # Queue data to be uploaded by the uploader thread
                log.d("putting downloaded data into the queue: {} atoms".format(len(json_response[ATOMS_KEY])))
                contents_queue.put(json_response)
            else:
                log.w("Unable to download tickers [{}]: {}".format(str_tickers, response.text))
            # Wait to sync with period
            wait_time = (start_time + period) - time.time()
            if wait_time > 0:
                print("Sleeping for {} seconds".format(wait_time))
                time.sleep(wait_time)

    def stop(self):
        '''
        Stops the download of data.
        '''
        self.execute = False

    @staticmethod
    def __prepare_data(contents: dict) -> dict:
        '''
        Converts downloaded contents into atoms
        '''
        atoms = contents['quotes']['quote']  # List of atoms
        data = {ATOMS_KEY: []}
        for atom in atoms:
            new_atom = {}
            # Grab only valuable data
            for key in TradierRealtime.VALUABLE:
                if atom.get(key, None) is not None:
                    new_atom[key] = atom[key]

            # Check if it's worth keeping
            for key in TradierRealtime.NECESSARY:
                # If any of the necessary keys contains data it's worth keeping
                if new_atom.get(key, 0) != 0:
                    break
            else:
                continue  # skip current atom

            # Localize exch
            for key in ("exch", "bidexch", "askexch"):
                try:
                    new_atom[key] = TradierRealtime.EXCHANGES[new_atom[key]]
                except KeyError:
                    log.v("Unable to localize {}: {}".format(key, new_atom))
            # Convert timestamp to datetime
            for key in ("trade_date", "bid_date", "ask_date"):
                if new_atom[key] != 0:
                    new_atom[key] = th.datetime_to_str(th.epoc_to_datetime(new_atom[key]/1000))
                else:
                    del new_atom[key]
            
            # Rename keys
            key_handler.rename_deep(new_atom, TradierRealtime.ALIASES)

            data[ATOMS_KEY].append(new_atom)

        # Append metadata
        data[METADATA_KEY] = {
            META_KEY_PROVIDER: META_VALUE_PROVIDER,
            META_KEY_TYPE: META_RT_VALUE_TYPE,
            META_KEY_DOWNLOAD_DT: th.now()
        }
        return data

    @staticmethod
    def __str_tickers(tickers: Sequence[str]):
        '''
        Converts a sequence of tickers into a string with commas separation.
        '''
        str_tickers = ""
        for ticker in tickers:
            str_tickers += ticker + ","
        str_tickers = str_tickers[:-1]
        return str_tickers
