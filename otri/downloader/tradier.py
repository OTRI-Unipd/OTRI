'''
Module that contains a wrapper for Tradier.com available data downloading.
'''

__author__ = "Luca Crema <lc.crema@hotmail.com>"
__version__ = "1.0"

from datetime import datetime
from typing import Any, Mapping, Sequence, Union

import requests

from otri.utils import key_handler
from otri.utils import logger as log
from otri.utils import time_handler as th

from . import (Intervals, RealtimeDownloader, RequestsLimiter,
               TimeseriesDownloader)

BASE_URL = "https://sandbox.tradier.com/v1/"

PROVIDER_NAME = "tradier"

EXCHANGES = {
    "A": "NYSE MKT",
    "B": "NASDAQ OMX BX",
    "C": "National Stock Exchange",
    "D": "FINRA ADF",
    "E": "Market Independent(Generated by Nasdaq SIP)",
    "F": "Mutual Funds/Money Markets(NASDAQ)",
    "I": "International Securities Exchange",
    "J": "Direct Edge A",
    "K": "Direct Edge X",
    "M": "Chicago Stock Exchange",
    "N": "NYSE",
    "P": "NYSE Arca",
    "Q": "NASDAQ OMX",
    "S": "NASDAQ Small Cap",
    "T": "NASDAQ Int",
    "U": "OTCBB",
    "V": "OTC other",
    "W": "CBOE",
    "X": "NASDAQ OMX PSX",
    "G": "GLOBEX",
    "Y": "BATS Y-Exchange",
    "Z": "BATS"
}


class TradierIntervals(Intervals):
    ONE_MINUTE = "1min"
    FIVE_MINUTES = "5min"
    FIFTEEN_MINUTES = "15min"


class TradierRequestsLimiter(RequestsLimiter):
    '''
    Handles tradier requests limitations by reading the response headers and findinding out how many requests are available.
    '''

    # Limit of available requests that the downloader should stop at. Must be >0.
    SAFE_LIMIT = 2

    def __init__(self):
        self._available_requests = 1
        self._next_reset = datetime(1, 1, 1)

    def _on_response(self, response_data: Any = None):
        '''
        Called when receiving a response. Updates the requests number.
        '''
        headers = response_data.headers
        self._available_requests = int(headers['X-Ratelimit-Available'])
        self._next_reset = th.epoch_to_datetime(int(headers['X-Ratelimit-Expiry'])/1000)  # In GMT time

    def waiting_time(self):
        '''
        Calculates the amount of time the downloader should wait in order not to exceed provider limitations.\n
        Returns:\n
            The amount of sleep time in seconds. 0 if no sleep time is needed.
        '''
        log.i("a:{} reset:{}".format(self._available_requests, th.datetime_to_str(self._next_reset)))
        if(self._available_requests > TradierRequestsLimiter.SAFE_LIMIT):
            return 0
        return (self._next_reset - datetime.utcnow()).total_seconds()


class TradierTimeseries(TimeseriesDownloader):
    '''
    Download timeseries data one symbol at a time.

    'last' price is the last price of the interval, 'close' is probably the average between ask and bid
    '''

    # Limiter with pre-setted variables
    DEFAULT_LIMITER = TradierRequestsLimiter()

    ts_aliases = {
        'last': 'price',
        'open': 'open',
        'high': 'high',
        'low': 'low',
        'close': 'close',
        'volume': 'volume',
        'vwap': 'vwap',
        'datetime': 'timestamp'
    }

    def __init__(self, api_key: str, limiter: RequestsLimiter):
        '''
        Parameters:\n
            api_key : str
                Sandbox user API key.\n
            limiter : RequestsLimiter
                A limiter object, should be shared with other downloaders too in order to work properly.\n
        '''
        super().__init__(provider_name=PROVIDER_NAME, intervals=TradierIntervals, limiter=limiter)
        self.key = api_key
        self._set_max_attempts(max_attempts=2)
        self._set_aliases(TradierTimeseries.ts_aliases)
        self._set_datetime_formatter(lambda dt: th.datetime_to_str(dt=th.epoch_to_datetime(dt)))
        self._set_request_timeformat("%Y-%m-%d %H:%M")

    def _history_request(self, ticker: str, start: str, end: str, interval: str = "1min"):
        '''
        Method that requires data from the provider and transform it into a list of atoms.\n
        Calls limiter._on_request to update the calls made.\n

        Parameters:\n
            ticker : str
                The simbol to download data of.\n
            start : str
                Download start date.\n
            end : str
                Download end date.\n
            interval : str
                Its possible values depend on the intervals attribute.\n
        '''
        self.limiter._on_request()
        response = self._http_request(ticker=ticker, interval=interval, start=start, end=end, timeout=3)

        if response is None or response is False:
            return False

        self.limiter._on_response(response)

        if response.status_code != 200:
            log.w("Error in Tradier request: {} ".format(str(response.content)))
            return False

        return response.json()['series']['data']

    def _http_request(self, ticker: str, interval: str, start: str, end: str, timeout: float) -> Union[requests.Response, bool]:
        return requests.get(BASE_URL + 'markets/timesales',
                            params={'symbol': ticker, 'interval': interval,
                                    'start': start, 'end': end, 'session_filter': 'all'},
                            headers={'Authorization': 'Bearer {}'.format(self.key), 'Accept': 'application/json'},
                            timeout=timeout
                            )


class TradierRealtime(RealtimeDownloader):
    '''
    Downloads realtime data by querying the provider multiple times.
    '''

    # Limiter with pre-setted variables
    DEFAULT_LIMITER = TradierRequestsLimiter()

    realtime_aliases = {
        'ticker': 'symbol',
        'exchange': 'exch',
        'bid exchange': 'bidexch',
        'ask exchange': 'askexch',
        'last': 'last',
        'volume': 'volume',
        'bid': 'bid',
        'ask': 'ask',
        'last volume': 'last_volume',
        'last trade date': 'trade_date',
        'bid size': 'bidsize',
        'last bid date': 'bid_date',
        'ask size': 'asksize',
        'last ask date': 'ask_date'
    }

    necessary_fields = [
        "volume",
        "bid",
        "ask",
        "last_volume",
        "trade_date"
    ]

    def __init__(self, key: str, limiter: RequestsLimiter):
        '''
        Parameters:\n
            key : str
                Sandbox user key.\n
            limiter : RequestsLimiter
                 A limiter object, should be shared with other downloaders too in order to work properly.\n
        '''
        super().__init__(PROVIDER_NAME, limiter)
        self.key = key
        self._set_aliases(TradierRealtime.realtime_aliases)
        self._set_necessary_fields(necessary=self.necessary_fields)

    def _realtime_request(self, tickers: Sequence[str]) -> Union[Sequence[Mapping], bool]:
        '''
        Method that requires the realtime data from the provider and transforms it into a list of atoms, one per ticker.
        '''
        self.limiter._on_request()
        response = self._http_request(tickers=tickers, timeout=2)

        if response is None or response is False:
            return False

        self.limiter._on_response(response)

        if response.status_code != 200:
            log.w("Error in Tradier request: {} ".format(str(response.content)))
            return False

        return response.json()['quotes']['quote']

    def _post_process(self, atoms: Sequence[Mapping]) -> Sequence[Mapping]:

        for atom in atoms:
            # Exchange localizing
            try:
                for key in ('bid exchange', 'ask exchange', 'exchange'):
                    atom[key] = EXCHANGES[atom[key]]
            except KeyError as e:
                log.w("error on exchange localization on {}: {}".format(atom, e))
            # Epochs to datetime
            try:
                for key in ('last trade date', 'last bid date', 'last ask date'):
                    atom[key] = th.datetime_to_str(th.epoch_to_datetime(epoch=int(atom[key])/1000))
            except KeyError as e:
                log.w("error on epoch parsing: {}".format(e))
        return atoms

    def _http_request(self, tickers: Sequence[str], timeout: float) -> Union[requests.Response, bool]:
        str_tickers = TradierRealtime._str_tickers(tickers)
        return requests.get(BASE_URL + 'markets/quotes',
                            params={'symbols': str_tickers, 'greeks': 'false'},
                            headers={'Authorization': 'Bearer {}'.format(self.key), 'Accept': 'application/json'},
                            timeout=timeout
                            )

    @staticmethod
    def _str_tickers(tickers: Sequence[str]) -> str:
        '''
        Converts a sequence of tickers into a string with commas separation.
        '''
        str_tickers = ""
        for ticker in tickers:
            ticker = ticker.replace(".", "/")  # Some tickers might be available with the slash instead of dot
            str_tickers += ticker + ","
        str_tickers = str_tickers[:-1]
        return str_tickers


class TradierMetadata:
    '''
    Retrieves metadata for tickers.
    '''

    ALIASES = {
        "symbol": "ticker",
        "exch": "exchange"
    }

    VALUABLE = {
        "symbol",
        "exchange",
        "type",
        "description",
        "root_symbols"
    }

    def __init__(self, key: str):
        '''
        Parameters:\n
            key : str
                Sandbox user key.
        '''
        self.key = key

    def info(self, tickers: Sequence[str], max_attempts: int = 2) -> Union[Sequence[dict], bool]:
        '''
        Retrieves information for every passed ticker.
        '''
        str_tickers = TradierRealtime._str_tickers(tickers)
        response = TradierRealtime._require_data(self.key, str_tickers)
        if(response in (False, None) or response.status_code != 200):
            return False
        return self.__prepare_data(response.json())

    @staticmethod
    def __prepare_data(contents: dict) -> Union[dict, bool]:
        '''
        Converts downloaded contents into atoms.
        '''
        try:
            atoms = contents['quotes']['quote']  # List of atoms
        except KeyError:
            return False
        if isinstance(atoms, dict):
            atoms = [atoms]
        data = []
        for atom in atoms:
            new_atom = {}
            # Filter
            for key in TradierMetadata.VALUABLE:
                value = atom.get(key, None)
                if value is not None:
                    new_atom[key] = value
            # Localize exchange
            if new_atom.get('exch', None) is not None:
                new_atom['exch'] = TradierRealtime.EXCHANGES[new_atom['exch']]
            # Rename
            new_atom = key_handler.rename_shallow(new_atom, TradierMetadata.ALIASES)

            # Add provider
            new_atom['provider'] = [TradierRealtime.META_VALUE_PROVIDER]
            # Append to output
            data.append(new_atom)
        return data
